        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************
        -:    2:*
        -:    3:* randomtestcard1.c
        -:    4:*
        -:    5:* -----------------
        -:    6:* Josh Huff 
        -:    7:* huffj@oregonstate.edu
        -:    8:* CS362 -- Spring 2018
        -:    9:* Assignment 5 
        -:   10:* -----------------
        -:   11:*
        -:   12:* Random Test for Paige Ribera's playSmithy in dominion.c
        -:   13:*
        -:   14:*************************************************************/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <math.h>
        -:   20:#include <time.h>
        -:   21:#include "dominion.h"
        -:   22:#include "dominion_helpers.h"
        -:   23:#include "interface.h"
        -:   24:#include "rngs.h"
        -:   25:
        -:   26:#define RANDOM_TEST_LOOPS 10000 
        -:   27:#define NORMAL_DECK_SIZE 100
        -:   28:#define NORMAL_HAND_SIZE 10
        -:   29:#define CARD_POOL 26
        -:   30:
        -:   31:int differences = 0;
        -:   32:
function randomTestSmithy called 10000 returned 100% blocks executed 78%
    10000:   33:void randomTestSmithy(struct gameState *original_state, int player, int handPos) {
        -:   34:
        -:   35:  struct gameState state_copy;
    10000:   36:  memcpy(&state_copy, original_state, sizeof(struct gameState));
        -:   37:
        -:   38:  int r;  
    10000:   39:  r = playSmithy(player, &state_copy, handPos);
call    0 returned 100%
    10000:   40:  r_asserttrue(r, 0);
call    0 returned 100%
        -:   41:  
        -:   42:  // Simulate adding Smithy to played pile
    10000:   43:  if(!r_asserttrue(original_state->playedCardCount, state_copy.playedCardCount - 1)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   44:
    #####:   45:    differences++;
        -:   46:  }    
        -:   47:
        -:   48:  // Simulate having drawn three cards (opponent is unchanged)     
    10000:   49:  if(!r_asserttrue(original_state->handCount[player], state_copy.handCount[player] - 2)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   50:
    10000:   51:    differences++;
        -:   52:  }  
        -:   53:  
    10000:   54:  if(!r_asserttrue(original_state->deckCount[!player], state_copy.deckCount[!player])){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   55:
    #####:   56:    differences++;
        -:   57:  }  
        -:   58:
    10000:   59:  if(!r_asserttrue(original_state->handCount[!player], state_copy.handCount[!player])){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   60:
    #####:   61:    differences++;
        -:   62:  }  
        -:   63:  
    10000:   64:  if(!r_asserttrue(original_state->discardCount[!player], state_copy.discardCount[!player])){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   65:
    #####:   66:    differences++;
        -:   67:  }    
        -:   68:  
    10000:   69:}
        -:   70:
function main called 1 returned 100% blocks executed 98%
        1:   71:int main(int argc, char *argv[]){
        -:   72:  
        -:   73:
        -:   74:  struct gameState state;
        -:   75:
        1:   76:  int k[10] = {adventurer, gardens, embargo, village, minion, 
        -:   77:               mine, cutpurse, sea_hag, tribute, smithy};
        -:   78:
        1:   79:  initializeGame(2, k, 2000, &state);
call    0 returned 100%
        1:   80:  printf("RANDOM TESTING playSmithy():\n");
call    0 returned 100%
        -:   81:  
        -:   82:  int i, n, currentPlayer, handPos; 
        -:   83:  clock_t time_started, time_elapsed;
        1:   84:  time_started = clock();
call    0 returned 100%
        -:   85:  
    10001:   86:  for(n = 0; n < RANDOM_TEST_LOOPS; n++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   87:    
    10000:   88:    time_elapsed = clock() - time_started;
call    0 returned 100%
        -:   89:    
    10000:   90:    if(((double)time_elapsed)/CLOCKS_PER_SEC > 295){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   91:        
    #####:   92:      return 0;
        -:   93:    }
        -:   94:  
263010000:   95:    for(i = 0; i < sizeof(struct gameState); i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   96:    
263000000:   97:      ((char*) &state)[i] = floor(Random() * 256);
call    0 returned 100%
        -:   98:    }
        -:   99:    
    10000:  100:    currentPlayer = floor(Random() * 2);
call    0 returned 100%
        -:  101:        
        -:  102:    // "Sane" Randomization of State Attributes
    10000:  103:    state.numPlayers = 2;
    10000:  104:    state.whoseTurn = currentPlayer;
        -:  105:
    10000:  106:    state.handCount[currentPlayer] = floor(Random() * NORMAL_HAND_SIZE);
call    0 returned 100%
    55696:  107:    for(i = 0; i < state.handCount[currentPlayer]; i++){
branch  0 taken 82%
branch  1 taken 18% (fallthrough)
        -:  108:      
    45696:  109:      state.hand[currentPlayer][i] = floor(Random() * CARD_POOL);
call    0 returned 100%
        -:  110:    }
        -:  111:    
    10000:  112:    state.deckCount[currentPlayer] = floor(Random() * NORMAL_DECK_SIZE);
call    0 returned 100%
   506479:  113:    for(i = 0; i < state.deckCount[currentPlayer]; i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -:  114:      
   496479:  115:      state.deck[currentPlayer][i] = floor(Random() * CARD_POOL);
call    0 returned 100%
        -:  116:    }
        -:  117:    
    10000:  118:    state.discardCount[currentPlayer] = floor(Random() * NORMAL_DECK_SIZE);
call    0 returned 100%
   506629:  119:    for(i = 0; i < state.discardCount[currentPlayer]; i++){
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -:  120:      
   496629:  121:      state.discard[currentPlayer][i] = floor(Random() * CARD_POOL);
call    0 returned 100%
        -:  122:    }
        -:  123:
    10000:  124:    state.playedCardCount = floor(Random() * NORMAL_HAND_SIZE);
call    0 returned 100%
    55411:  125:    for(i = 0; i < state.playedCardCount; i++){
branch  0 taken 82%
branch  1 taken 18% (fallthrough)
        -:  126:      
    45411:  127:      state.playedCards[i] = floor(Random() * CARD_POOL);
call    0 returned 100%
        -:  128:    }  
        -:  129:
    10000:  130:    handPos = floor(Random() * state.handCount[currentPlayer]);
call    0 returned 100%
        -:  131:
    10000:  132:    randomTestSmithy(&state, currentPlayer, handPos);
call    0 returned 100%
        -:  133:  }
        -:  134:  
        1:  135:  printf("Differences:%d\n", differences);
call    0 returned 100%
        1:  136:  return 0;
        -:  137:}
