        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************
        -:    2:*
        -:    3:* cardtest1.c
        -:    4:*
        -:    5:* -----------------
        -:    6:* Josh Huff 
        -:    7:* huffj@oregonstate.edu
        -:    8:* CS362 -- Spring 2018
        -:    9:* Assignment 5 
        -:   10:* -----------------
        -:   11:*
        -:   12:* Unit Test for Paige Ribera's playSmithy in dominion.c
        -:   13:*
        -:   14:*************************************************************/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <math.h>
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include "interface.h"
        -:   23:#include "rngs.h"
        -:   24:
function testSmithy called 1 returned 100% blocks executed 86%
        1:   25:void testSmithy() {
        -:   26:
        1:   27:  int k[10] = {adventurer, feast, baron, mine, great_hall, 
        -:   28:               remodel, smithy, village, ambassador, embargo};
        -:   29:            
        1:   30:  int players = 2;
        -:   31:  int beforeHandSize, beforeDeckSize, beforeDiscardSize, beforeOppHand, beforeOppDeck, beforeOppDiscard;
        1:   32:  int beforeVictory = 0;
        1:   33:  int afterVictory = 0;
        1:   34:  int beforeKingdom = 0;
        1:   35:  int afterKingdom = 0;
        1:   36:  int seed = 1000;
        -:   37:
        -:   38:  struct gameState state; 
        -:   39:
        1:   40:  memset(&state, 23, sizeof(struct gameState));
        1:   41:  initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   42:  
        1:   43:  int currentPlayer = whoseTurn(&state);
call    0 returned 100%
        -:   44:
        1:   45:  beforeHandSize = state.handCount[currentPlayer];
        1:   46:  beforeDeckSize = state.deckCount[currentPlayer];
        1:   47:  beforeDiscardSize = state.discardCount[currentPlayer];
        -:   48:  
        -:   49:  // NEW TEST Criteria -- ensure opponent's hand and deck are unchanged
        1:   50:  beforeOppHand = state.handCount[!currentPlayer];
        1:   51:  beforeOppDeck = state.deckCount[!currentPlayer];  
        -:   52:  
        -:   53:  int i;
       11:   54:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   55:  
       10:   56:    beforeKingdom += k[i];
        -:   57:  }
        -:   58:  
        -:   59:  int j;
        4:   60:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   61:  
        3:   62:    beforeVictory += state.supplyCount[j];
        -:   63:  }
        -:   64:
        1:   65:  printf("\nTESTING playSmithy():\n");
call    0 returned 100%
        -:   66:  // Force one of the opening cards to be "Smithy."
        1:   67:  state.hand[currentPlayer][beforeHandSize - 1] = 13;
        1:   68:  printf("Hand contents before playing Smithy:\n");
call    0 returned 100%
        1:   69:  printHand(currentPlayer, &state);
call    0 returned 100%
        -:   70:
        1:   71:  playSmithy(currentPlayer, &state, beforeHandSize - 1);
call    0 returned 100%
        -:   72:
        -:   73:// Test 1 -- Current player should receive exact 3 cards.
        1:   74:  printf("Test: Current player should receive exact 3 cards.\n");
call    0 returned 100%
        1:   75:  if(!asserttrue(state.handCount[currentPlayer], beforeHandSize + 2)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   76:    
        1:   77:    printf("Hand size before drawing: %d\n", beforeHandSize);
call    0 returned 100%
        1:   78:    printf("Hand size after drawing: %d\n", state.handCount[currentPlayer]);
call    0 returned 100%
        1:   79:    printHand(currentPlayer, &state);
call    0 returned 100%
        -:   80:  }
        -:   81:
        -:   82:// Test 2 -- Drawn cards should come from his own deck.
        1:   83:  printf("Test: Three cards came from the sum of player's deck and discard piles.\n");
call    0 returned 100%
        1:   84:  if(!asserttrue(state.deckCount[currentPlayer] + state.discardCount[currentPlayer], beforeDeckSize + beforeDiscardSize - 3)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   85:  
        1:   86:    printf("Deck + discard size before playing Smithy: %d\n", beforeDeckSize + beforeDiscardSize);
call    0 returned 100%
        1:   87:    printf("Deck + discard size after playing Smithy: %d\n", state.deckCount[currentPlayer] + state.discardCount[currentPlayer]);
call    0 returned 100%
        -:   88:  }
        -:   89:
        -:   90:// NEW TEST, 2a
        1:   91:  printf("Test: No cards came from opponent's deck, discard, or hand.\n");
call    0 returned 100%
        -:   92:
        1:   93:  if(!asserttrue(state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer], 
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:   94:                 beforeOppHand + beforeOppDeck + beforeOppDiscard)){
        -:   95:    
    #####:   96:    printf("Opponent Hand + deck + discard size before drawing: %d\n", beforeOppHand + beforeOppDeck + beforeOppDiscard);
call    0 never executed
    #####:   97:    printf("Opponent Hand + deck + discard size after drawing: %d\n", state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer]);
call    0 never executed
        -:   98:  }
        -:   99:      
        -:  100:// Test 3 -- No state change should occur to the victory card piles and kingdom card piles.
        1:  101:  printf("Test: No state change to victory and kingdom card piles.\n");
call    0 returned 100%
        -:  102:
       11:  103:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  104:  
       10:  105:    afterKingdom += k[i];
        -:  106:  }
        -:  107:
        4:  108:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  109:  
        3:  110:    afterVictory += state.supplyCount[j];
        -:  111:  }
        -:  112:
        1:  113:  if(!asserttrue(beforeKingdom + beforeVictory, afterKingdom + afterVictory)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  114:  
    #####:  115:    printf("Kingdom size before drawing: %d\n", beforeKingdom);
call    0 never executed
    #####:  116:    printf("Kingdom size after drawing: %d\n", afterKingdom);
call    0 never executed
    #####:  117:    printf("Victory size before drawing: %d\n", beforeVictory);
call    0 never executed
    #####:  118:    printf("Victory size after drawing: %d\n", afterVictory);    
call    0 never executed
        -:  119:  }
        -:  120:
        1:  121:}
        -:  122:
function main called 1 returned 100% blocks executed 100%
        1:  123:int main(int argc, char *argv[]){
        -:  124:  
        1:  125:  testSmithy();
call    0 returned 100%
        1:  126:  return 0;
        -:  127:}
