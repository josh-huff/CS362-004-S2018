        -:    0:Source:cardtest1_fixed.c
        -:    0:Graph:cardtest1_fixed.gcno
        -:    0:Data:cardtest1_fixed.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************
        -:    2:*
        -:    3:* cardtest1.c
        -:    4:*
        -:    5:* -----------------
        -:    6:* Josh Huff 
        -:    7:* huffj@oregonstate.edu
        -:    8:* CS362 -- Spring 2018
        -:    9:* Assignment 5 
        -:   10:* -----------------
        -:   11:*
        -:   12:* Unit Test for Paige Ribera's playSmithy in dominion.c
        -:   13:*
        -:   14:*************************************************************/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <math.h>
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include "interface.h"
        -:   23:#include "rngs.h"
        -:   24:
function testSmithy called 1 returned 100% blocks executed 74%
        1:   25:void testSmithy() {
        -:   26:
        1:   27:  int k[10] = {adventurer, feast, baron, mine, great_hall, 
        -:   28:               remodel, smithy, village, ambassador, embargo};
        -:   29:            
        1:   30:  int players = 2;
        -:   31:  int beforeHandSize, beforeDeckSize, beforeDiscardSize, beforeOppHand, beforeOppDeck, beforeOppDiscard;
        1:   32:  int beforeVictory = 0;
        1:   33:  int afterVictory = 0;
        1:   34:  int beforeKingdom = 0;
        1:   35:  int afterKingdom = 0;
        1:   36:  int seed = 1000;
        -:   37:
        -:   38:  struct gameState state; 
        -:   39:
        1:   40:  memset(&state, 23, sizeof(struct gameState));
        1:   41:  initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   42:  
        1:   43:  int currentPlayer = whoseTurn(&state);
call    0 returned 100%
        -:   44:
        1:   45:  beforeHandSize = state.handCount[currentPlayer];
        1:   46:  beforeDeckSize = state.deckCount[currentPlayer];
        1:   47:  beforeDiscardSize = state.discardCount[currentPlayer];
        -:   48:  
        -:   49:  // NEW TEST Criteria -- ensure opponent's hand and deck are unchanged
        1:   50:  beforeOppHand = state.handCount[!currentPlayer];
        1:   51:  beforeOppDeck = state.deckCount[!currentPlayer];  
        1:   52:  beforeOppDiscard = state.discardCount[!currentPlayer];
        -:   53:  
        -:   54:  int i;
       11:   55:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   56:  
       10:   57:    beforeKingdom += k[i];
        -:   58:  }
        -:   59:  
        -:   60:  int j;
        4:   61:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   62:  
        3:   63:    beforeVictory += state.supplyCount[j];
        -:   64:  }
        -:   65:
        1:   66:  printf("\n-----TESTING playSmithy():\n");
call    0 returned 100%
        -:   67:  // Force one of the opening cards to be "Smithy."
        1:   68:  state.hand[currentPlayer][beforeHandSize - 1] = 13;
        1:   69:  printf("Hand contents before playing Smithy:\n");
call    0 returned 100%
        1:   70:  printHand(currentPlayer, &state);
call    0 returned 100%
        -:   71:
        1:   72:  playSmithy(currentPlayer, &state, beforeHandSize - 1);
call    0 returned 100%
        -:   73:
        -:   74:// Test 1 -- Current player should receive exact 3 cards.
        1:   75:  printf("Test: Current player should receive exact 3 cards.\n");
call    0 returned 100%
        1:   76:  if(!asserttrue(state.handCount[currentPlayer], beforeHandSize + 2)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   77:    
    #####:   78:    printf("Hand size before drawing: %d\n", beforeHandSize);
call    0 never executed
    #####:   79:    printf("Hand size after drawing: %d\n", state.handCount[currentPlayer]);
call    0 never executed
    #####:   80:    printHand(currentPlayer, &state);
call    0 never executed
        -:   81:  }
        -:   82:
        -:   83:// Test 2 -- Drawn cards should come from his own deck.
        1:   84:  printf("Test: Three cards came from the sum of player's deck and discard piles.\n");
call    0 returned 100%
        1:   85:  if(!asserttrue(state.deckCount[currentPlayer] + state.discardCount[currentPlayer], beforeDeckSize + beforeDiscardSize - 3)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   86:  
    #####:   87:    printf("Deck + discard size before playing Smithy: %d\n", beforeDeckSize + beforeDiscardSize);
call    0 never executed
    #####:   88:    printf("Deck + discard size after playing Smithy: %d\n", state.deckCount[currentPlayer] + state.discardCount[currentPlayer]);
call    0 never executed
        -:   89:  }
        -:   90:
        -:   91:// NEW TEST, 2a
        1:   92:  printf("Test: No cards came from opponent's deck, discard, or hand.\n");
call    0 returned 100%
        -:   93:
        1:   94:  if(!asserttrue(state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer], 
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:   95:                 beforeOppHand + beforeOppDeck + beforeOppDiscard)){
        -:   96:    
    #####:   97:    printf("Opponent Hand + deck + discard size before drawing: %d\n", beforeOppHand + beforeOppDeck + beforeOppDiscard);
call    0 never executed
    #####:   98:    printf("Opponent Hand + deck + discard size after drawing: %d\n", state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer]);
call    0 never executed
        -:   99:  }
        -:  100:      
        -:  101:// Test 3 -- No state change should occur to the victory card piles and kingdom card piles.
        1:  102:  printf("Test: No state change to victory and kingdom card piles.\n");
call    0 returned 100%
        -:  103:
       11:  104:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  105:  
       10:  106:    afterKingdom += k[i];
        -:  107:  }
        -:  108:
        4:  109:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  110:  
        3:  111:    afterVictory += state.supplyCount[j];
        -:  112:  }
        -:  113:
        1:  114:  if(!asserttrue(beforeKingdom + beforeVictory, afterKingdom + afterVictory)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  115:  
    #####:  116:    printf("Kingdom size before drawing: %d\n", beforeKingdom);
call    0 never executed
    #####:  117:    printf("Kingdom size after drawing: %d\n", afterKingdom);
call    0 never executed
    #####:  118:    printf("Victory size before drawing: %d\n", beforeVictory);
call    0 never executed
    #####:  119:    printf("Victory size after drawing: %d\n", afterVictory);    
call    0 never executed
        -:  120:  }
        -:  121:
        1:  122:}
        -:  123:
function main called 1 returned 100% blocks executed 100%
        1:  124:int main(int argc, char *argv[]){
        -:  125:  
        1:  126:  testSmithy();
call    0 returned 100%
        1:  127:  return 0;
        -:  128:}
