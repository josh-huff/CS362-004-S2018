        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************
        -:    2:*
        -:    3:* cardtest2.c
        -:    4:*
        -:    5:* -----------------
        -:    6:* Josh Huff 
        -:    7:* huffj@oregonstate.edu
        -:    8:* CS362 -- Spring 2018
        -:    9:* Assignment 5 
        -:   10:* -----------------
        -:   11:*
        -:   12:* Unit Test for Paige Ribera's playAdventurer in dominion.c
        -:   13:*
        -:   14:*************************************************************/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <math.h>
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include "interface.h"
        -:   23:#include "rngs.h"
        -:   24:
function testAdventurer called 1 returned 100% blocks executed 73%
        1:   25:void testAdventurer() {
        -:   26:
        1:   27:  int k[10] = {adventurer, feast, baron, mine, great_hall, 
        -:   28:               remodel, smithy, village, ambassador, embargo};
        -:   29:            
        1:   30:  int players = 2;
        -:   31:  int beforeHandSize, beforeDeckSize, beforeDiscardSize, beforeOppHand, beforeOppDeck, beforeOppDiscard;
        1:   32:  int beforeVictory = 0;
        1:   33:  int afterVictory = 0;
        1:   34:  int beforeKingdom = 0;
        1:   35:  int afterKingdom = 0;
        1:   36:  int seed = 1000;
        -:   37:  struct gameState state; 
        -:   38:
        1:   39:  memset(&state, 23, sizeof(struct gameState));
        1:   40:  initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   41:
        1:   42:  beforeHandSize = state.handCount[0];
        1:   43:  beforeDeckSize = state.deckCount[0];
        1:   44:  beforeDiscardSize = state.discardCount[0];
        -:   45:  
        -:   46:  int i;
       11:   47:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   48:  
       10:   49:    beforeKingdom += k[i];
        -:   50:  }
        -:   51:  
        -:   52:  int j;
        4:   53:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   54:  
        3:   55:    beforeVictory += state.supplyCount[j];
        -:   56:  }
        -:   57:  
        1:   58:  int drawntreasure = 0;
        1:   59:  int cardDrawn = 0;
        -:   60:  int temphand[MAX_HAND];
        1:   61:  int currentPlayer = whoseTurn(&state);
call    0 returned 100%
        -:   62:  
        -:   63:  // NEW TEST Criteria -- ensure opponent's hand and deck are unchanged
        1:   64:  beforeOppHand = state.handCount[!currentPlayer];
        1:   65:  beforeOppDeck = state.deckCount[!currentPlayer];
        1:   66:  beforeOppDiscard = state.discardCount[!currentPlayer];
        -:   67:    
        1:   68:  printf("\nTESTING playAdventurer():\n");
call    0 returned 100%
        -:   69:  // Force one of the opening cards to be "Adventurer."
        1:   70:  state.hand[currentPlayer][beforeHandSize - 1] = 7;
        1:   71:  printf("Hand contents before playing Adventurer:\n");
call    0 returned 100%
        1:   72:  printHand(currentPlayer, &state);  
call    0 returned 100%
        -:   73:
        1:   74:  playAdventurer(drawntreasure, &state, currentPlayer, cardDrawn, temphand);
call    0 returned 100%
        -:   75:
        -:   76:// Test 1 -- Current player should receive 2 cards.
        1:   77:  printf("Test: Current player should have exactly 1 more card in hand.\n");
call    0 returned 100%
        -:   78:
        1:   79:  if(!asserttrue(state.handCount[currentPlayer], beforeHandSize + 1)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   80:  
        1:   81:    printf("Hand size before drawing: %d\n", beforeHandSize);
call    0 returned 100%
        1:   82:    printf("Hand size after drawing: %d\n", state.handCount[currentPlayer]);    
call    0 returned 100%
        1:   83:    printHand(currentPlayer, &state);
call    0 returned 100%
        -:   84:  }
        -:   85:
        -:   86:// Test 2 -- 2 cards should come from his own deck.
        1:   87:  if(!asserttrue(state.deckCount[currentPlayer] + state.discardCount[currentPlayer], beforeDeckSize + beforeDiscardSize - 2)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:   88:  
        1:   89:    printf("Deck + discard size before drawing: %d\n", beforeDeckSize + beforeDiscardSize);
call    0 returned 100%
        1:   90:    printf("Deck + discard size after drawing: %d\n", state.deckCount[currentPlayer] + state.discardCount[currentPlayer]);
call    0 returned 100%
        -:   91:  }
        -:   92:
        -:   93:// NEW TEST, 2a
        1:   94:  printf("Test: No cards came from opponent's deck.\n");
call    0 returned 100%
        -:   95:
        1:   96:  if(!asserttrue(state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer], 
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:   97:                 beforeOppHand + beforeOppDeck + beforeOppDiscard)){
        -:   98:    
    #####:   99:    printf("Opponent Hand + deck + discard size before drawing: %d\n", beforeOppHand + beforeOppDeck + beforeOppDiscard);
call    0 never executed
    #####:  100:    printf("Opponent Hand + deck + discard size after drawing: %d\n", state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer]);
call    0 never executed
        -:  101:  }               
        -:  102:      
        -:  103:// Test 3 -- No state change should occur to the victory card piles and kingdom card piles.
        1:  104:  printf("Test: No state change to victory and kingdom card piles.\n");
call    0 returned 100%
        -:  105:
       11:  106:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  107:  
       10:  108:    afterKingdom += k[i];
        -:  109:  }
        -:  110:
        4:  111:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  112:  
        3:  113:    afterVictory += state.supplyCount[j];
        -:  114:  }
        -:  115:
        1:  116:  if(!asserttrue(beforeKingdom, afterKingdom) || !asserttrue(beforeVictory, afterVictory)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  117:  
    #####:  118:    printf("Kingdom size before drawing: %d\n", beforeKingdom);
call    0 never executed
    #####:  119:    printf("Kingdom size after drawing: %d\n", afterKingdom);
call    0 never executed
    #####:  120:    printf("Victory size before drawing: %d\n", beforeVictory);
call    0 never executed
    #####:  121:    printf("Victory size after drawing: %d\n", afterVictory);    
call    0 never executed
        -:  122:  }
        -:  123:
        -:  124:
        -:  125:// Test 4 -- No Treasure was Discarded
        1:  126:  printf("Test:  No Treasure was Discarded. (possibly zero necessary tests)\n");
call    0 returned 100%
        -:  127:  
        1:  128:  int discarded = abs(beforeDiscardSize - state.discardCount[currentPlayer]);
        1:  129:  int discardTop = state.discardCount[currentPlayer] - 1;
        -:  130:  int m;
        -:  131:
        1:  132:  if (discarded != 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  133:
    #####:  134:    for (m = 0; m < discarded; m++){
branch  0 never executed
branch  1 never executed
        -:  135:  
    #####:  136:      if(!asserttrue(state.discard[currentPlayer][discardTop] > 3 && state.discard[currentPlayer][discardTop] < 7, 0)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  137:      
        -:  138:        //printf("Card in discard pile is %d\n", state.discard[currentPlayer][discardTop]);
    #####:  139:        printDiscard(currentPlayer, &state);
call    0 never executed
        -:  140:      }
    #####:  141:      discardTop--;
        -:  142:    }
        -:  143:  }
        -:  144:  
        -:  145:  else{
        -:  146:  
        1:  147:    printf("Test Not Applicable: No discards made.\n");
call    0 returned 100%
        -:  148:  }
        -:  149:  
        -:  150:  
        -:  151:// Test 5 -- Only Treasure was Drawn
        1:  152:  printf("Test:  Only Treasure was Drawn. (two tests)\n");
call    0 returned 100%
        -:  153:  
        -:  154:  int n;
        1:  155:  int drawnLast = state.handCount[currentPlayer] - 1;
        3:  156:  for (n = 0; n < 2; n++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  157:  
        2:  158:    if(!asserttrue(state.hand[currentPlayer][drawnLast] > 3 && state.hand[currentPlayer][drawnLast] < 7, 1)){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  159:      
        -:  160:      //printf("Last drawn card is %d\n", state.hand[currentPlayer][drawnLast]);
    #####:  161:      printHand(currentPlayer, &state);
call    0 never executed
        -:  162:    }
        2:  163:    drawnLast--;
        -:  164:  }
        -:  165:
        1:  166:}
        -:  167:
function main called 1 returned 100% blocks executed 100%
        1:  168:int main(int argc, char *argv[]){
        -:  169:  
        1:  170:  testAdventurer();
call    0 returned 100%
        1:  171:  return 0;
        -:  172:}
