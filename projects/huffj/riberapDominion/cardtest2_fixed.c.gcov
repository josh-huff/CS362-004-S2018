        -:    0:Source:cardtest2_fixed.c
        -:    0:Graph:cardtest2_fixed.gcno
        -:    0:Data:cardtest2_fixed.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/************************************************************
        -:    2:*
        -:    3:* cardtest2.c
        -:    4:*
        -:    5:* -----------------
        -:    6:* Josh Huff 
        -:    7:* huffj@oregonstate.edu
        -:    8:* CS362 -- Spring 2018
        -:    9:* Assignment 5 
        -:   10:* -----------------
        -:   11:*
        -:   12:* Unit Test for Paige Ribera's playAdventurer in dominion.c
        -:   13:*
        -:   14:*************************************************************/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include <math.h>
        -:   20:#include "dominion.h"
        -:   21:#include "dominion_helpers.h"
        -:   22:#include "interface.h"
        -:   23:#include "rngs.h"
        -:   24:
function testAdventurer called 1 returned 100% blocks executed 67%
        1:   25:void testAdventurer() {
        -:   26:
        1:   27:  int k[10] = {adventurer, feast, baron, mine, great_hall, 
        -:   28:               remodel, smithy, village, ambassador, embargo};
        -:   29:            
        1:   30:  int players = 2;
        -:   31:  int beforeHandSize, beforeDeckSize, beforeDiscardSize, beforeOppHand, beforeOppDeck, beforeOppDiscard;
        1:   32:  int beforeVictory = 0;
        1:   33:  int afterVictory = 0;
        1:   34:  int beforeKingdom = 0;
        1:   35:  int afterKingdom = 0;
        1:   36:  int seed = 1000;
        -:   37:  struct gameState state; 
        -:   38:
        1:   39:  memset(&state, 23, sizeof(struct gameState));
        1:   40:  initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   41:
        1:   42:  int currentPlayer = whoseTurn(&state);
call    0 returned 100%
        -:   43:  
        1:   44:  beforeHandSize = state.handCount[currentPlayer];
        1:   45:  beforeDeckSize = state.deckCount[currentPlayer];
        1:   46:  beforeDiscardSize = state.discardCount[currentPlayer];
        -:   47:
        -:   48:  // NEW TEST Criteria -- ensure opponent's hand and deck are unchanged
        1:   49:  beforeOppHand = state.handCount[!currentPlayer];
        1:   50:  beforeOppDeck = state.deckCount[!currentPlayer];
        1:   51:  beforeOppDiscard = state.discardCount[!currentPlayer];
        -:   52:
        1:   53:  int handPos = beforeHandSize - 1;
        1:   54:  int drawntreasure = 0;
        1:   55:  int cardDrawn = 0;
        -:   56:  int temphand[MAX_HAND];
        -:   57:  
        -:   58:  int i;
       11:   59:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:  
       10:   61:    beforeKingdom += k[i];
        -:   62:  }
        -:   63:  
        -:   64:  int j;
        4:   65:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:   66:  
        3:   67:    beforeVictory += state.supplyCount[j];
        -:   68:  }
        -:   69:  
        -:   70:    
        1:   71:  printf("\n-----TESTING playAdventurer():\n");
call    0 returned 100%
        -:   72:  // Force one of the opening cards to be "Adventurer."
        1:   73:  state.hand[currentPlayer][beforeHandSize - 1] = 7;
        1:   74:  printf("Hand contents before playing Adventurer:\n");
call    0 returned 100%
        1:   75:  printHand(currentPlayer, &state);  
call    0 returned 100%
        -:   76:
        1:   77:  playAdventurer(drawntreasure, &state, currentPlayer, cardDrawn, temphand, handPos);
call    0 returned 100%
        -:   78:
        -:   79:// Test 1 -- Current player should receive 2 cards.
        1:   80:  printf("Test: Current player should have exactly 1 more card in hand.\n");
call    0 returned 100%
        -:   81:
        1:   82:  if(!asserttrue(state.handCount[currentPlayer], beforeHandSize + 1)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   83:  
    #####:   84:    printf("Hand size before drawing: %d\n", beforeHandSize);
call    0 never executed
    #####:   85:    printf("Hand size after drawing: %d\n", state.handCount[currentPlayer]);    
call    0 never executed
    #####:   86:    printHand(currentPlayer, &state);
call    0 never executed
        -:   87:  }
        -:   88:
        -:   89:// Test 2 -- 2 cards should come from his own deck.
        1:   90:  if(!asserttrue(state.deckCount[currentPlayer] + state.discardCount[currentPlayer], beforeDeckSize + beforeDiscardSize - 2)){
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:   91:  
    #####:   92:    printf("Deck + discard size before drawing: %d\n", beforeDeckSize + beforeDiscardSize);
call    0 never executed
    #####:   93:    printf("Deck + discard size after drawing: %d\n", state.deckCount[currentPlayer] + state.discardCount[currentPlayer]);
call    0 never executed
        -:   94:  }
        -:   95:
        -:   96:// NEW TEST, 2a
        1:   97:  printf("Test: No cards came from opponent's deck.\n");
call    0 returned 100%
        -:   98:
        1:   99:  if(!asserttrue(state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer], 
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        1:  100:                 beforeOppHand + beforeOppDeck + beforeOppDiscard)){
        -:  101:    
    #####:  102:    printf("Opponent Hand + deck + discard size before drawing: %d\n", beforeOppHand + beforeOppDeck + beforeOppDiscard);
call    0 never executed
    #####:  103:    printf("Opponent Hand + deck + discard size after drawing: %d\n", state.deckCount[!currentPlayer] + state.handCount[!currentPlayer] + state.discardCount[!currentPlayer]);
call    0 never executed
        -:  104:  }               
        -:  105:      
        -:  106:// Test 3 -- No state change should occur to the victory card piles and kingdom card piles.
        1:  107:  printf("Test: No state change to victory and kingdom card piles.\n");
call    0 returned 100%
        -:  108:
       11:  109:  for (i = 0; i < 10; i++){
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  110:  
       10:  111:    afterKingdom += k[i];
        -:  112:  }
        -:  113:
        4:  114:  for (j = 1; j < 4; j++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  115:  
        3:  116:    afterVictory += state.supplyCount[j];
        -:  117:  }
        -:  118:
        1:  119:  if(!asserttrue(beforeKingdom, afterKingdom) || !asserttrue(beforeVictory, afterVictory)){
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  120:  
    #####:  121:    printf("Kingdom size before drawing: %d\n", beforeKingdom);
call    0 never executed
    #####:  122:    printf("Kingdom size after drawing: %d\n", afterKingdom);
call    0 never executed
    #####:  123:    printf("Victory size before drawing: %d\n", beforeVictory);
call    0 never executed
    #####:  124:    printf("Victory size after drawing: %d\n", afterVictory);    
call    0 never executed
        -:  125:  }
        -:  126:
        -:  127:
        -:  128:// Test 4 -- No Treasure was Discarded
        1:  129:  printf("Test:  No Treasure was Discarded. (possibly zero necessary tests)\n");
call    0 returned 100%
        -:  130:  
        1:  131:  int discarded = abs(beforeDiscardSize - state.discardCount[currentPlayer]);
        1:  132:  int discardTop = state.discardCount[currentPlayer] - 1;
        -:  133:  int m;
        -:  134:
        1:  135:  if (discarded != 0){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  136:
    #####:  137:    for (m = 0; m < discarded; m++){
branch  0 never executed
branch  1 never executed
        -:  138:  
    #####:  139:      if(!asserttrue(state.discard[currentPlayer][discardTop] > 3 && state.discard[currentPlayer][discardTop] < 7, 0)){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
branch  5 never executed
branch  6 never executed
        -:  140:      
        -:  141:        //printf("Card in discard pile is %d\n", state.discard[currentPlayer][discardTop]);
    #####:  142:        printDiscard(currentPlayer, &state);
call    0 never executed
        -:  143:      }
    #####:  144:      discardTop--;
        -:  145:    }
        -:  146:  }
        -:  147:  
        -:  148:  else{
        -:  149:  
        1:  150:    printf("Test Not Applicable: No discards made.\n");
call    0 returned 100%
        -:  151:  }
        -:  152:  
        -:  153:  
        -:  154:// Test 5 -- Only Treasure was Drawn
        1:  155:  printf("Test:  Only Treasure was Drawn. (two tests)\n");
call    0 returned 100%
        -:  156:  
        -:  157:  int n;
        1:  158:  int drawnLast = state.handCount[currentPlayer] - 1;
        3:  159:  for (n = 0; n < 2; n++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  160:  
        2:  161:    if(!asserttrue(state.hand[currentPlayer][drawnLast] > 3 && state.hand[currentPlayer][drawnLast] < 7, 1)){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
call    4 returned 100%
branch  5 taken 0% (fallthrough)
branch  6 taken 100%
        -:  162:      
        -:  163:      //printf("Last drawn card is %d\n", state.hand[currentPlayer][drawnLast]);
    #####:  164:      printHand(currentPlayer, &state);
call    0 never executed
        -:  165:    }
        2:  166:    drawnLast--;
        -:  167:  }
        -:  168:  
        1:  169:  printf("Hand contents after playing Adventurer:\n");
call    0 returned 100%
        1:  170:  printHand(currentPlayer, &state); 
call    0 returned 100%
        -:  171:
        1:  172:}
        -:  173:
function main called 1 returned 100% blocks executed 100%
        1:  174:int main(int argc, char *argv[]){
        -:  175:  
        1:  176:  testAdventurer();
call    0 returned 100%
        1:  177:  return 0;
        -:  178:}
